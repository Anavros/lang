
Delimiters:
- { } Braces denote blocks of statements. Each statement in a block terminates with a semicolon.
- ( ) Parentheses show lists of expressions. Expressions are separated by commas. A comma may optionally follow the last item in a list.
- [ ] Brackets are used for various type constructs.
- < > Angle brackets are reserved for comparison operators.

Or:
- ( ) Parens are for tuples and function applications.
- [ ] Brackets are for lists and are also reused as type specs.

fun example(int x) {
    statement1;
    statement2;
}

struct Point[N] {
    N x, y, z;
}
# Or
struct Point[N] (N x, N y, N z);

items = Vector[Int](1, 2, 3, 4, 5);
tuple = (1, 2, 3);
hashmap = (
    "a" = 1,
)
hashmap = (a=1, b=2, c=3);
# Should maps allow omission of quotes for string keys?
# Probably not.
# But it does conflict with named arguments in functions.
hashmap = [a=1, b=2, c=3];
hashmap = [1='a', 2='b', 3='c'];

# There really needs to be a way to visually join
# braced statements together.

if x {
} else {
}
# Vs
if x { }
else { }
# Vs
if x {
}
else {
}

# But how?


###
Concept:
-> Remove braces or at least semicolons.
Motivation:
-> They are a little visually cluttering.
-> The primary motivation for keeping delimiters
is explicitely marking where statements end.
-> Notably, this makes multi-line statements much
easier to handle.
-> If we have a dedicated method for multi-line
statements (and perhaps another for
multi-statement lines), then we might be able to
axe the delimiters.
###

normal statement;
function(a, b) {
    statement;
}
not_in_function;
str = "Really long statement which doesn't really"
    + "map onto one line nicely and has to be"
    + "broken up into multiple parts.";
MyObject()
    .do()
    .the()
    .thing();
multilinecall(
    a=1,
    b=2,
    c=3,
);
monitor {
    f();
} status {
    Ok { g(); }
}

# Vs
normal statement
function(a, b)
    statement
not_in_function
str = "Really long statement which doesn't really"
    + "map onto one line nicely and has to be"
    + "broken up into multiple parts."
MyObject()
    .do()
    .the()
    .thing()
multilinecall(
    a=1,
    b=2,
    c=3,
);
monitor
    f()
status
    Ok: g()

# Basically the two important ingredients here are
# line continuations and block delimiting. Which
# are kind of the same in an abstract sense.

# There is probably a small, finite set of general
# approaches.

# Beginning and end tokens.
function %
    statment
%

# Keyword marked beginning and explicit end.
function
    statement
%

# Indent counting.
function
    statement

# But then there's also the problem of joining
# several smaller statments together.

monitor % f() % status % Ok % g() % %

monitor f()
status
    Ok g()

# So really there's another problem presenting
# itself here. Why are some statements required to
# split onto a new line, and how do you join them
# back together?
