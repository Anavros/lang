
###
Is there a good alternative to generic types?
(Look into "System F<:" aka system f subtype theory.)
It's all about establishing invariants at compile-time. Assert as many things as
possible will not change over the course of execution.
###

# A node in a linked list can hold any value.
Node[T] = (
    value:T,
    next:Node[T],
);

# Concatenate a linked list of strings in order.
concat = (head:Node[String]) {
    result = "";
    loop {
        result += head.value;
        if head.next == None {
            break;
        } else {
            head = head.next;
        };
    };
    return result;
};

s : Node[String]();
result = concat(s);
n : Node[Num]();
?????? = concat(n);  # Will it work?

# What about type-defined standard functions, like python's __iter__?
concat = (head:Node[String]) {
    result = "";
    for value in head.iterate() {
        result += head.value;
    };
    return result;
};


s : Array[String];
head = (a:Array[String]) : String {
    return a.at(0);
};
head(s) : String;

a : Array;
head = (a:Array) : ? {
    return a.at(0);
};
head(a) : ?;

###
Requirements for sum:
    a has to have iter
    e has to have a base value to be summed upon
    e has to support addition
###
sum = (a:?) : ? {
    result = e.base();  # what is the base case for the elements in a?
    for e in a.iter() {
        # e must allow the addition operator!
        result += e;
    };
    return result;
};

###
There are really two sides to the same coin. Functions need certain invariants
to ensure that they will work, and types need to explain what invariants they
can fulfill. So maybe it would be more natural to separate the type declaration
from the function parameters.
###

invariant Summable {
    A:iter() :: Iter[E];
    E:base() :: E;
    E + E    :: E;
};

sum = (a:Iterable[Addable]) {
};

###
Generics might be fulfilled by good usage of interfaces. Imagine a sorting
function. Each item being sorted must have a comparison function, and that's it.
So no need for generics.
###

sort = (a:Iter[Compare]) {
    for e in a {
        if e > a ...
    };
};

###
Maybe it's only parameter specs that need generics, right? If you have a linked
list, say, just put whatever you want in there. But when its time for a function
to use a linked list, it will specify that it needs a certain interface for
those elements.
###

Link[T] = (value:T, next:Link);

# Doesn't need to know anything about included types.
head = (l:Link) { };
# Specifies that links must support adding.
sum = (l:Link[Add]) { };
# What if you just passed in a function that could add two items?
sum = (l:Link, adder:Function) { };

###
Interesting Note
It's not important to know what you have a sequence of, but rather what the
common functionality of every item in the sequence is. So you might have a bunch
of ints, floats, and strings, but all of them can be rendered as strings.

Although.
Some things might work when the sequence is homogenous, but won't work when it's
heterogenous. If you have an array of adders, where ints, floats, and strings
can all be added, they can't necessarily be added together.

Is python's single-dispatch approach better? Imagine iterating over a sequence.
Any object that defines the __iter__ method abstracts away that concern.
###
