
###
Concept:
-> Monads are cool.
-> They can be used to provide external context to
a function call.
-> They can also represent state as a series of
transformations on an initial value.
-> Implementing monads, or something similar,
could help simplify our state machines and make
things like undos, synchronizing, and algebraic
reasoning possible.
-> Having an option type might actually simplify
exception handling.
###

Result[T, E] = Failure(Error:E) | Success(Value:T)

fun div(num:den:Int):(n:Result[Int, DivideByZero]) {
    if dem == 0 {
        return Failure(DivideByZero);
    }
    return Success(num/den);
}

n = div(x, y) : Result[Int, DivideByZero];

match n {
    Failure(e) { }
    Success(v) { }
}

# But image all of this built right in.

fun div(num:den:Int):(n:Int) {
    if dem == 0 {
        fail DivideByZero;
    }
    return num/den;
}

# The other thing was default values.

fun longfunc(x:y:z:Num, stdin=None, stdout=None);
fun longfunc(x:y:z:Num, stdin=Option[File], stdout?) {
    stdin == Option[];
}

# I'm not sure how I thought that would work.
