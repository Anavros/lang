
###
Blocks are generic, first class objects. Arguments within parens can be applied
inside the block scope. Generic connection between types and funcs?
###

x = 10;
{
    x;  # 10
};

(x) {
    x;  # whatever x is given
};

function = (x, y) {
    print(x);
    print(y);
};

Type = (x, y, z);

###
Inheritly two kinds of blocks: those that take on the enclosing scope, and those
that ask for variables explicitly.

Lexical scoping over dynamic scoping.

Notice the difference between blocks that run inline, and blocks that are run
elsewhere.
###

# Inline block, no control flow.
# Notice the closure over x.
x = 10;
{
    print(x);
};

# Contrast.
x = 10;
f = {
    # Doesn't run until f() is called.
    # The value of x is frozen to what it is when the function is defined.
    print(x);
};

# Explicit variables.
(v) {
    print(v);
};
map((v){print(v);}, items);


# What about type constructors?
# Structs are just parameterized tuples.
Point = (x:y:z:Float);
Health = (
    hp:Num,
    # No more functions allowed in structs.
);
Monster = Point :: Health :: (name:Str);
# vs
# Monster : Point + Health + (name:Str);

# Compare a structure definition with a normal value tuple.
Type = (foo:String, bar:Num);
numbers = (1, 2, 3);
# So tuples are like anonymous, unnamed structs.


# What about conditionals?
# Can users create their own control flow operators?
if f() == true {
} else {
};

keyword bool { block; } keyword { block; };

if {
    # block
};
if (x) {
    # 'x' is a condition, not an input variable!
};

# Or loops?
for x in sequence {
};
# Equivalent to...
(sequence[0]) { }
(sequence[1]) { }
...
(sequence[n]) { }
