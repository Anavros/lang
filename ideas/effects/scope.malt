

# For global variables, there are two options I
# think. Either mark a function as having a global
# scope, allowing it to have access to global
# variables, or cherry-pick which variables to
# access using a keyword.

global counter = 0;

global fun increment() {
    counter += 1;
    # What happens if you declare variables in
    # here? Are they local or global?
}
# Function mark is more explicit, but might
# include too many globals? What if you don't want
# all of them? Is that a real problem?
# Might mesh well with public function
# declarations?

fun increment() {
    global counter += 1;
}
# Allows choosing variables explicitely. Not as
# clear that the function as a whole is accessing
# global variables.

# Maybe a hybrid option could involve setting a
# block's scope to global.

fun increment() @global{
    counter += 1;
}

fun increment() {
    # Local scope.
    @global{
        # Global scope.
        counter += 1;
    }
}

###
Well, you usually don't want to include every single global variable, only a
set few.
###

# Mark that the block uses the global namespace, without actually passing it in.
# Then access the counter variable under the global namespace.
increment = @global {
    global.counter += 1;
};

# How does that work with multiple scopes?
x = 1;
do @outside {
    outside.x = 2;
    do @outside {
        outside.outside.x = 3;
        do @outside {
            outside.outside.outside.x = 4;
            do @outside {
                print(outside.outside.outside.x);
            };
        };
    };
};

# That's only if you want to modify outside variables.
# Is it a problem to modify a variable from outside? It shouldn't be, because
# scopes are lexical, not dynamic, so code blocks like this can only affect
# variables that are present in the source next to it.

x = 1;
do {
    x = 2;
    print(x);  # 2
};
print(x);  # 1

x = 1;
do {
    print(x);  # error; what x?
};
do (x) {
    print(x);  # 1; x is an explicit parameter
}(x);  # the function call, could be omitted when using 'do'.

# Creates a function object but doesn't bind it to anything or call it.
{
    print(x);
};

# Creates and immediately calls a function object, but doesn't pass any
# parameters.
do {
    print(x);
};

# Same thing but imports the variable x from the outside scope.
do ^(x) {
    print(x);
};

# Potential different syntax. Not as clear but could be implied by 'do'?
do (x) {
    print(x);
};

f = (x) {
    print(x);
};
do f;  # does this work?

# Can you use this syntax to create dynamically scoped functions?
f = ^(x) {
    print(x);
};

# How does that affect loops and other control structures?
example = (x:Bool, message:String) {
    if x (^) {
        print(^message);  # message not declared in this scope
    } else {
        print("nope");
    };
};

another = (n:Num) {
    for i in range(n) {
        print(i);
    };
    for(in(i, range(n)), (^) { print(^i); } );
};

# Redo of that contrived multi-stack example.
x = 1;
do (^) {
    ^x++;
    do (^) {
        ^^x++;
        do (^) {
            print(^^^x);
        };
    };
};

# Maybe it could work without the parameter tuple?
do {
    ^x++;
};

f = {
    ^x++;
};

import module;
main = {
    ^module.do_something();
};

# Alternative method, which may end up being less verbose.
x = 1;
do {
    x++;
    do {
        x++;
        do {
            print(x);
        };
    };
};

x = 1;
do {
    local x = 5;
    print(x);
};

# Is that clear enough?
i = 0;
do {
    for i in range(10) {
        print(i);
    };
};
# Is i == 0 or i == 9?

# Should we just use python's rules? To use the most local scope available?
x = 1;
do {
    x = 5;
    print(x);  # 5
};
print(x);  # 1

# Do we need two kinds of blocks? One that's more expression-oriented and
# closure friendly?
map(x => x*2, items);
