
Node = Type[N=Int] {
    x = y = z = N(0);
}

Node = Type [N=Int] (x=y=z=N(0)) { }
Node = Type [N=Int] (x=y=z=N(0));

n = Node();
n = Node[Float]();
n = Node[Float](y=5);

Mapping = Type [K, V];

m = Mapping[String, Num]();
m.add("Hello", 1);

NDimPoint = Type[N=Int] (ndim:Num, init=N(0)) {
    for i in range(ndim) {
        blockscope@(f"d{i+1}") = init;
    }
}
two_dim_point = NDimPoint[Float](2);
two_dim_point.d1, two_dim_point.d2;

contradiction = Func (p:NDimPoint)

# What goes into the Type constructor?

Type [types] (parameters) {assignments}

Type [T=String, U=String];

# How does it relate to functions?

Func [types] (parameters) {statements}

# What working references do we have?
n = Num(1, max=10);
p = Point[Int](1, 2, 3);

# What's the worst case, space-wise?

ReallyLongTypeThatTBHWouldFitRightInAtJava =
Type [T, U, V, XCLASS, YCLASS] (
    one:two:three:T,
    four:five:U,
    six:seven:eight:nine:ten:eleven:V,
    xclass:XCLASS,
    yclass:YCLASS,
    name:String
) {
    statements;
}

# Maybe type constructors are just like functions.

cls Point(x:y:z:Float) {
    cls.x = x;
    cls.y = y;
    cls.z = z;
}

fun new_point(x:y:z:Float) {
    Point p;
    p.x = x;
    p.y = y;
    p.z = z;
    return p;
}
