
Concept:
- Built-in partial application of functions that's used consistently throughout
  the language.
- Infix operators are going to be a little tricky. We either have to use some
  confusing syntax or just refer to them by their proper names.

def func(a, b) {
    return a < b
}

partial = func(a, ?)
partial(b)

string has iter

match <has iter> {
    string: f()
}

# Maybe match should use brackets because values inside are essentially a list.
# They're separated by commas after all (or maybe by newlines?).
match func(5, ?) [
    1: f()
    6: f()
]

match <func 5> [
]

def complicated(w, x, y, z) {
}

match complicated(?, ?, 5, ?) {
    4, 5, 6: f()
}

partial = complicated(1, ?, ?, 3)
partial(4, 5) # Is that order ambiguous?

def really_bad(x, y, z, kw1=1, kw2=2) {
}

partial = really_bad(3, ?, ?, kw2=5) {
}
partial(y, z, kw1=1)

Can we name arguments that don't have default values?
def function(x=?, y=?, z=?, kw1=1, kw2=2) {
}
I guess that's kind of what happens anyway.

So what about the infix operations then?
And how do these all interact with stuff like match?

string has iter
has(string, iter)
has(?, iter)
has(string, ?)
<has iter>
<string has>
<(1, ?)
<< 1>
(< 1)
ordered(?, 1)  # what about inclusive/exclusive orders?

match a {
    a has logicalopts: f()
    _ {
        g()
    }
} else {
    g()
}
