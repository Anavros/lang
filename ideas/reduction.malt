
###
Concept:
-> Type A can be reduced to type B if A fulfills
all functionality of B. That is, A is superset of
B.
-> This has a lot of similarity to the class
inheritance pattern found in common OO languages.
-> The difference is that there is not a strict
hierarchy. A can be superset to B without having
any relation to B.
###

# Imagine two types A and B.
A = Type (i:j:Num);
B = Type (i:j:Num, x:y:z:Float);

# A contains two elements i and j. B contains the
# same elements i and j in addition to three more
# x, y, and z.

# B contains all elements of A, therefore B is
# superset to A.

# Imagine a function f that takes one argument of
# type A.
f = Func (a:A) {
    # Elements of type A can be used inside the
    # function body.
    print(a.i);
    print(a.j);
}

# And so calling f with an instance of A succeeds.
f(A());

# In practical terms, f accepts arguments of type
# A because type A guarantees that the argument
# will have a certain set of elements available
# for the function to use.

# Because type B is a superset of type A, calling
# f with an argument of type B *must* succeed
# because B contains all elements of A.
f(B());

# So any type B can be substituted for any type A
# if B is superset to A.
