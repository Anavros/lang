
###
Types can accept parameters that restrict their allowed values. This goes hand
in hand with generics.

I'm not sure what should happen at compile time and what at runtime, or if it
even matters for type restrictions.

Type restrictions might play a role in contracts too?
###

Int;
Int[-100,+100];
Array[Int[0,10]];

type Datetime {
    month   : Int[1,12];
    day     : Int[1,31];
    hour    : Int[0,23];
    minute  : Int[1,60];
    second  : Int[1,60];
}

func index[T](a:Array[T], i:Int[0,a.len]) : T;

###
What happens when constraints are broken?
Consider the number case at least. If you have an n : Num[1, 10], and you assign
100 to it, what happens? It could cause an error, wrap around back to 1, or
constrain to 10.

It could be an option that defaults to causing an error.
###

n : Num[1, 10];
n = 5;  # fine
n = 10; # error
n : Num[1, 10, overflow="wrap"];
n = 5;  # fine
n = 15; # fine, n actually equals what?

# Maybe separate assignment and mutation. Assigning an invalid range always
# fails. Overflowing when wrap is set is like a modulous operation. Constrain is
# more like a min/max assignment.

n : Num[1, 10, overflow="wrap"];
n = 5;  # fine
n = 15; # error
n += 6; # n wraps over into 5+6 % 10 == 1
n += 5; # n wraps over into 5+5 % 10 == 0? that's not good
