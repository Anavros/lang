
fundamental Array {
    DefinedInImplementation
}

struct Vector {
    Array items;
    fun iterate() {
    }
}

struct Hashmap {
    Array pairs;
}

fun iterate(container) {
    # But the Hashmap has a variable called pairs!
    for x in container.items {
    }

    # I think the better way to do it is to follow
    # go's example and only allow function
    # interfaces. So that way the internal
    # variables can be named whatever.
    for x in container.iterate() {
    }
}

interface iterable {
    fun iterate(): something;
}

fun iterate(iterable container) {
    for x in container.iterate() {
        f(x);
    }
}

###
Ideas:
- Static checking is performed on traits instead of types.
- Algebraic data types a la haskell.
- Data is stored in structures.
- Structures can be associated with functions.
- Maybe they all can be wrapped under one type name.
- Types can be checked for member variables or associated functions.
- Runtime creation of new structure members is not allowed.
- All definitions have to happen in the type definition.
- No additional impl blocks as in rust.
- No tacking on additional functions to basic types as in ruby.
###


struct Consumable {
    String flavor;
    Int kilograms;
}

type Drink {
    Consumable c;
    Int liters;
}

struct Snack {
    # this is just the same thing as inheritance
    Consumable c;
    Float saltiness;
}

struct Meal {
    Consumable c;
    Int deliciousness;
    Bool gluten_free;
}

fun eat(Consumable c) {
    print(c.flavor);
    print("This weighs {c.kilograms} kilos!");
}

