
Ideas:
- We might need a different function definition syntax that's a little more
long-winded so we can allow arbitrary specification of traits.
- What about having "where x has ... {" blocks that will only execute if a
variable has a certain trait.
- Partial application should be built-in.
- We want pretty light-weight lambda functions too.
- Maybe have some way of making early returns more clear?


def myfunc(truthy b, iterable sexy a) {
    return if not b
    # something to do with vague control flow?
    # return leaves early, so no if/else check? it makes sense
    # but it can be hard to read
    for x in a {
        .print(a)
    }
}

def anytraits(a, b) {
    return b, a
}

def wow(stupid sexy flanders) {
}

What about input cases like haskell?

def n(int a) {
    match a {
        a < 0: f()
        a == 0: g()
        a > 0: h()
    }
}

# These would all be about the same
def func(a, b) {
    where a has .next {
    }
    if a has .next {
    }
    match partial_application(has a) {
        .next:
    }
}

def func(a, b) where a, b are int { }
def func(a, b) where a has iter { }
def func(int iter a, int b) { }
def func(a, b, c, d, e, f, g, h) where
    a is int and has iter
    and b is int
    and c has other
    and d is string
    and e has indexing
    and f has realopt and other
    and g is string
    and h is string {
}
def func(int iter a, int b, other c, string d, indexing e,
    realopt other f, string g, string h) {
}
# Can we allow arbitrary boolean expressions?
# This for instance would have to be checked at runtime.
def func(a) where a != 0 {
}
# Or maybe a limited set of type specifications.
def func(a) where a has intcmp {
}

# And what about return values?
int func(int a) { }
def int func(int a) { }
def func(int a) => int { }
func(int a) => void { }
func(int a) { }
