
###
A property p(x) where x is of type t should hold
true as p(y) if y is of type s that is subtype of
type t.
###

###
Concept:
-> Codify what types are considered substitutable.
-> Traditional object orientation uses
inheritance, but we're going to use mixins.
-> Using hierarchy of numbers as an example.
###

###
Conceptually, type S reduces to type T if T is
less precise than S.
###

# In this case, '<' implies less precise.
Natural < Integer < Rational < Real < Complex

type Natural {
    fn n() { }
}
type Integer {
    fn n() { }
    fn abs() { }
}
type Rational {
    fn n() { }
    fn abs() { }
    fn mantissa() { }
}
type Real {
    fn n() { }
    fn abs() { }
    fn mantissa() { }
    fn repeating() { }
}
type Complex {
    fn n() { }
    fn abs() { }
    fn mantissa() { }
    fn repeating() { }
    fn imaginary() { }
}

fun increment(Natural n) : Natural {
    # Should take all numbers, because each class
    # of number can be reduced to Natural.
    return n.n()+1;
    # Incedentally, what should the return type
    # be? If you pass a Real, you shouldn't be
    # getting a Natural in return.
}

fun swap_imaginary(Complex c) : Complex {
    # Only works on Complex because no other
    # number can be reduced to Complex.
    c.n, c.imaginary = c.imaginary, c.n;
}
