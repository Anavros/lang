
struct [N] Point {
    N x, y, z;
}

# Point has to work transparently for all types.
datatype Int;
datatype Float;
struct Complex {
    Float r, i;
}

# And what about 2D or 3D points?
Point2D;
Point3D;
Point4D;

struct [N] Point2D { N x, y }
struct [N] Point3D { N x, y, z }
struct [N] Point4D { N x, y, z, q }

a2 = [Int] Point2D(1, 2);
a3 = [Int] Point3D(1, 2, 3);
a4 = [Int] Point4D(1, 2, 3, 4);
b2 = [Float] Point2D(1.0, 2.0);
b3 = [Float] Point3D(1.0, 2.0, 3.0);
b4 = [Float] Point4D(1.0, 2.0, 3.0, 4.0);
c2 = [Complex] Point2D(
    Complex(2.0, -1.0),
    Complex(3.0, -1.0),
);
c3 = [Complex] Point3D(
    Complex(2.0, -1.0),
    Complex(3.0, -1.0),
    Complex(5.0, -1.0),
);
c4 = [Complex] Point4D(
    Complex(2.0, -1.0),
    Complex(3.0, -1.0),
    Complex(5.0, -1.0),
    Complex(8.0, -1.0),
);

# Not very efficient.

# Do these even need to be conflated?
# What about something like a zeroing function?

#fun [N] zero(Point p) : Point {
fun zero(Point p, Type n = Int) : Point {
    x = n(0) for x in p;
}

# That in theory would work the same for every
# kind of point. But honestly it's probably way
# too complicated.

# What about something even more generic?
fun swap(a, b) : ? {
    a, b = b, a;
}
# That should definitely work for all types.
fun map(Function f, Sequence seq) : Sequence {
    new = Sequence();
    for item in old {  # what type is item?
        new.push(f(item));  # which push() func?
    }
    return new;
}

# How do you decide what to accept when asking for
# a certain type in a function?

fun magnify(Point p, Int n) : Point {
    for m in structmembers(p) {
        m *= n;
        #m! * n;
    }
}
