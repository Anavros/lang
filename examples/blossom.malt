
Item = {
    name:Str;
    amount:Num;
};

Inventory = {
    items:List[Item];
    give();
    take();
};

Health = {
    hp:Num;
    armor:Real;
    hurt();
    heal();
    kill();
}

Location = {
    Plains=Forest=Ocean=Token;
    move();
};

Achievements = {
    flirted_with_death:Bool;
    juggled_knives:Bool;
    climbed_large_tree:Bool;
}

Player = Inventory + Location + Achievements
+ Health + {
    name:String;
    deaths:Num;
};

Vehicle = Inventory + Location + {
    speed:Real;
};

Func(p:Player);

Func(i:Inventory);  # Will this only accept
# Inventory objects, or also include any superset
# of Inventory?

# Should be superset, right? Unless it isn't clear
# enough that that's the intention.

Func(m:Location+Achievements); # Has to have both?

player = Player();
player.give(item);
player.take(item);
player.hurt(5);
player.heal(5);
player.move(Location.Ocean);

vehicle.move();
vehicle.hurt();
vehicle.give();



###
Player = Inventory + Location + Player Stats
Inventory = [Item] Sequence + Capacity
Item = Name + Amount
Location = Area + Side

Vehicle = Inventory + Location + Movement Stats
###

struct Item {
    name : String;
    amount : Int;
}
# apples = Item("Apple", 10);

struct Inventory[Int n] {
    items: List[Item, len = n];
}
# inv = Inventory[5]();

datatype Area { Plains, Ocean, Woods }
datatype Side { In, Out }

struct Location {
    area = Area.Plains;
    side = Side.In;
}
# loc = Location(Area.Ocean, Side.Out);

struct Player {
    inv : Inventory;
    loc : Location;
    name : String;
    deaths : Int = 0;
}
# p = Player(Inventory[5](), Location(), "Bim");

struct Vehicle {
    inv : Inventory;
    loc : Location;
    name : String;
    speed : Int;
}
player.inv.items[0].name;
player.loc.area;
player.name;
player.deaths;

###
Name Import Mechanic
###

struct Player {
    include Inventory as inv;
    include Location as loc;
    name : String;
    deaths : Int;
}
player.items[0].name;  # from inv
player.area;  # from loc

# If two structs contain the same name, accessing
# the name will cause a failure. The name must be
# accessed through the structure's alias.

# Assume location has a name variable.
player.name;  # failure
player.loc.name;  # safe access
# But how to access the normal player.name?
